name: Deploy to Raspberry Pi

on:
  push:
    branches:
      - staging
      - main
  workflow_dispatch: # Manual trigger

jobs:
  deploy:
    runs-on: [self-hosted, pi]
    timeout-minutes: 30
    defaults:
      run:
        working-directory: /home/david/apps/zero-email

    steps:
      - name: Pull latest code
        run: |
          git fetch origin ${{ github.ref_name }}
          git reset --hard origin/${{ github.ref_name }}

      - name: Build and deploy with Docker Compose
        run: |
          docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml pull --ignore-pull-failures
          docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml up -d --build --remove-orphans

      - name: Run database migrations
        run: |
          # Force re-run migrations (one-shot containers don't re-run on `up`)
          docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml rm -f migrations || true
          docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml up --build migrations
          echo "Migrations completed"

      - name: Ensure AI settings columns exist
        run: |
          # Drizzle migrations can fail on "already exists" errors from older migrations
          # This ensures the AI settings columns exist regardless of migration state
          # Uses the server container which has DATABASE_URL already configured
          docker exec zero-server node -e "
            const postgres = require('postgres');
            const sql = postgres(process.env.DATABASE_URL);
            (async () => {
              await sql\\\`ALTER TABLE mail0_user_settings ADD COLUMN IF NOT EXISTS encrypted_openai_key text\\\`;
              await sql\\\`ALTER TABLE mail0_user_settings ADD COLUMN IF NOT EXISTS encrypted_gemini_key text\\\`;
              console.log('AI settings columns ensured');
              await sql.end();
            })().catch(e => console.log('Error or columns exist:', e.message));
          " || echo "Migration step completed"

      - name: Cleanup old images
        run: docker image prune -f

      - name: Wait for services to be healthy
        run: |
          echo "Waiting for services to start..."
          sleep 30

          # Wait for server to be healthy (up to 2 minutes)
          for i in {1..24}; do
            if docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml ps server | grep -q "healthy"; then
              echo "Server is healthy"
              break
            fi
            echo "Waiting for server to be healthy... ($i/24)"
            sleep 5
          done

      - name: Health check
        run: |
          curl -sf --insecure https://localhost/health || exit 1
          echo "Health check passed!"

      - name: Show service status
        run: docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml ps

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== Server Logs ==="
          docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml logs --tail=100 server
          echo ""
          echo "=== Nginx Logs ==="
          docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml logs --tail=50 nginx
          echo ""
          echo "=== All Services Status ==="
          docker compose -f docker-compose.standalone.yaml -f docker-compose.pi.yaml -f docker-compose.tailscale.yaml ps -a
